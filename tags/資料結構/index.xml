<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>資料結構 on 程式漂流小屋</title>
    <link>https://happylittle7.github.io/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/</link>
    <description>Recent content in 資料結構 on 程式漂流小屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-TW</language>
    <lastBuildDate>Sun, 23 Jan 2022 18:35:05 +0800</lastBuildDate><atom:link href="https://happylittle7.github.io/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>並查集(Disjoint Sets)</title>
      <link>https://happylittle7.github.io/p/disjoint-sets/</link>
      <pubDate>Sun, 23 Jan 2022 18:35:05 +0800</pubDate>
      
      <guid>https://happylittle7.github.io/p/disjoint-sets/</guid>
      <description>並查集(Disjoint Sets)，是一個可以用來維護元素和集合關係的資料結構，
基本操作 初始化 int n=1000; //假設共有n個點 int dsu[1000]; //建一個紀錄集合編號的陣列，若dsu[n]==n，代表為根  //初始化集合 void initt(){ for(int i=0;i&amp;lt;=n;i++){ //初始每個集合只有自己  dsu[i]=i; } } 查詢 //傳入要找尋的目標 int findd(int x){ if(x!=dsu[x]){ //往上尋找祖先，再遞迴更新路上遇到的節點  dsu[x]=Find(dsu[x]); } return dsu[x]; } 合併 void unionn(int x,int y){ int a=findd(x); int b=findd(y); //若集合編號不相同，則進行合併，  if(a!=b){ dsu[a]=b; } } </description>
    </item>
    
  </channel>
</rss>
